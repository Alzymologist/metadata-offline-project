# Milestone 1

## 1.1. Publish refined requirements for protocol

TODO

## 1.2. Publish first draft of mock shortened metadata for parallel development

As it turns out, it was way easier to write an actual shortening code than attempt to write mock shortened metadata manually. Example of shortening prototype can be found in [substrate-parser](https://github.com/Alzymologist/substrate-parser/blob/main/examples/automated_short_meta.rs) repository. By running `cargo run --example automated_short_meta` in that repository, basic statistics on metadata and content of transaction as decoded using shortened version could be seen.

```
length of basic meta: 300431
length of shortened meta: 1479
TransactionParsed { call_result: Ok(Call(PalletSpecificData { pallet_info: Info { docs: "", path: Path { segments: ["pallet_utility", "pallet", "Call"] } }, variant_docs: "", pallet_name: "Utility", variant_name: "batch_all", fields: [FieldData { field_name: Some("calls"), type_name: Some("Vec<<T as Config>::RuntimeCall>"), field_docs: "", data: ExtendedData { data: SequenceRaw(SequenceRawData { element_info: [Info { docs: "", path: Path { segments: ["westend_runtime", "RuntimeCall"] } }], data: [Call(Call(PalletSpecificData { pallet_info: Info { docs: "", path: Path { segments: ["pallet_staking", "pallet", "pallet", "Call"] } }, variant_docs: "", pallet_name: "Staking", variant_name: "bond", fields: [FieldData { field_name: Some("value"), type_name: Some("BalanceOf<T>"), field_docs: "", data: ExtendedData { data: PrimitiveU128 { value: 1061900000000, specialty: Balance }, info: [] } }, FieldData { field_name: Some("payee"), type_name: Some("RewardDestination<T::AccountId>"), field_docs: "", data: ExtendedData { data: Variant(VariantData { variant_name: "Staked", variant_docs: "", fields: [] }), info: [Info { docs: "", path: Path { segments: ["pallet_staking", "RewardDestination"] } }] } }] })), Call(Call(PalletSpecificData { pallet_info: Info { docs: "", path: Path { segments: ["pallet_staking", "pallet", "pallet", "Call"] } }, variant_docs: "", pallet_name: "Staking", variant_name: "nominate", fields: [FieldData { field_name: Some("targets"), type_name: Some("Vec<AccountIdLookupOf<T>>"), field_docs: "", data: ExtendedData { data: SequenceRaw(SequenceRawData { element_info: [Info { docs: "", path: Path { segments: ["sp_runtime", "multiaddress", "MultiAddress"] } }], data: [Variant(VariantData { variant_name: "Id", variant_docs: "", fields: [FieldData { field_name: None, type_name: Some("AccountId"), field_docs: "", data: ExtendedData { data: Id(08264834504a64ace1373f0c8ed5d57381ddf54a2f67a318fa42b1352681606d (5CFPcUJg...)), info: [Info { docs: "", path: Path { segments: ["sp_core", "crypto", "AccountId32"] } }] } }] }), Variant(VariantData { variant_name: "Id", variant_docs: "", fields: [FieldData { field_name: None, type_name: Some("AccountId"), field_docs: "", data: ExtendedData { data: Id(aebb0211dbb07b4d335a657257b8ac5e53794c901e4f616d4a254f2490c43934 (5G1ojzh4...)), info: [Info { docs: "", path: Path { segments: ["sp_core", "crypto", "AccountId32"] } }] } }] }), Variant(VariantData { variant_name: "Id", variant_docs: "", fields: [FieldData { field_name: None, type_name: Some("AccountId"), field_docs: "", data: ExtendedData { data: Id(9ae581fef1fc06828723715731adcf810e42ce4dadad629b1b7fa5c3c144a81d (5FZoQhgU...)), info: [Info { docs: "", path: Path { segments: ["sp_core", "crypto", "AccountId32"] } }] } }] })] }), info: [] } }] }))] }), info: [] } }] })), extensions: [ExtendedData { data: Composite([]), info: [Info { docs: "", path: Path { segments: ["frame_system", "extensions", "check_non_zero_sender", "CheckNonZeroSender"] } }] }, ExtendedData { data: Composite([]), info: [Info { docs: "", path: Path { segments: ["frame_system", "extensions", "check_spec_version", "CheckSpecVersion"] } }] }, ExtendedData { data: Composite([]), info: [Info { docs: "", path: Path { segments: ["frame_system", "extensions", "check_tx_version", "CheckTxVersion"] } }] }, ExtendedData { data: Composite([]), info: [Info { docs: "", path: Path { segments: ["frame_system", "extensions", "check_genesis", "CheckGenesis"] } }] }, ExtendedData { data: Composite([FieldData { field_name: None, type_name: Some("Era"), field_docs: "", data: ExtendedData { data: Era(Era::Mortal(64, 5)), info: [Info { docs: "", path: Path { segments: ["sp_runtime", "generic", "era", "Era"] } }] } }]), info: [Info { docs: "", path: Path { segments: ["frame_system", "extensions", "check_mortality", "CheckMortality"] } }] }, ExtendedData { data: Composite([FieldData { field_name: None, type_name: Some("T::Index"), field_docs: "", data: ExtendedData { data: PrimitiveU32 { value: 2, specialty: Nonce }, info: [] } }]), info: [Info { docs: "", path: Path { segments: ["frame_system", "extensions", "check_nonce", "CheckNonce"] } }] }, ExtendedData { data: Composite([]), info: [Info { docs: "", path: Path { segments: ["frame_system", "extensions", "check_weight", "CheckWeight"] } }] }, ExtendedData { data: Composite([FieldData { field_name: None, type_name: Some("BalanceOf<T>"), field_docs: "", data: ExtendedData { data: PrimitiveU128 { value: 0, specialty: Tip }, info: [] } }]), info: [Info { docs: "", path: Path { segments: ["pallet_transaction_payment", "ChargeTransactionPayment"] } }] }, ExtendedData { data: Tuple([]), info: [] }, ExtendedData { data: PrimitiveU32 { value: 9430, specialty: SpecVersion }, info: [] }, ExtendedData { data: PrimitiveU32 { value: 7, specialty: TxVersion }, info: [] }, ExtendedData { data: GenesisHash(0xe143f23803ac50e8f6f8e62695d1ce9e4e1d68aa36c1cd2cfd15340213f3423e), info: [Info { docs: "", path: Path { segments: ["primitive_types", "H256"] } }] }, ExtendedData { data: BlockHash(0x5b1d91c89d3de85a4d6eee76ecf3a303cf38b59e7d81522eb7cd24b02eb161ff), info: [Info { docs: "", path: Path { segments: ["primitive_types", "H256"] } }] }, ExtendedData { data: Tuple([]), info: [] }, ExtendedData { data: Tuple([]), info: [] }, ExtendedData { data: Tuple([]), info: [] }] }
```

Notice, that metadata for a complex composite batched transaction fits in under 1.5kB, as desired. The shortened metadata is saved in `for_tests/westend9430_short_for_transaction`, original metadata is taken from `for_tests/westend9430`. You can replace original metadata and hardcoded transaction with any others, just remember to change genesis hash that is not part of metadata.

The only part missing there is information on proofing that might be needed in some possible implementation. A placeholder of 256 bits or something similar could be appended to metadata for modeling; we do not know the nature of that part yet, so let's leave it at this.

## 1.3. Estimate shortened metadata size frames based on information theory

TODO

## 1.4. Coordination

TODO

## 1.5. Analyze alternative hashing/storage strategies to Merkle tree

TODO

